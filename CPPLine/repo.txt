
================================================================================
// File: Main.cpp
================================================================================

// main.cpp
import std;
import CPPLine;

int main(int argc, char* argv[]) {
    using namespace cppline;

    Parser parser("Demo Application");

    // Register options with aliases
    parser.add_bool({ "--verbose", "-v" }, "Enable verbose output");
    parser.add_int({ "-n", "--number" }, "Set the number", 10);
    parser.add_string({ "--name" }, "Set the name", "default");
    parser.add_option({ "--keyvalue" }, "Set a key-value pair",
                      [](const std::vector<std::string_view>& args) -> std::any {
                          if (args.empty()) {
                              throw std::runtime_error("Expected key:value pair");
                          }
                          std::string arg = std::string(args[0]);
                          auto pos = arg.find(':');
                          if (pos == std::string::npos) {
                              throw std::runtime_error("Invalid format, expected key:value");
                          }
                          std::string key = arg.substr(0, pos);
                          std::string value{ args[1] };
                          return std::make_pair(key, value);
                      },
                      2);

    // Collect arguments
    std::vector<std::string_view> arguments;
    for (int i = 1; i < argc; ++i) {
        arguments.push_back(argv[i]);
    }

    // Check for help option
    auto is_help = [](std::string_view arg) { return arg == "--help" || arg == "-h"; };

    if (std::any_of(arguments.begin(), arguments.end(), is_help)) {
        parser.print_help();
        return 0;
    }

    // Parse arguments
    try {
        parser.parse(arguments);
    }
    catch (const std::exception& ex) {
        std::cerr << "Parsing error: " << ex.what() << "\n";
        parser.print_help();
        return 1;
    }

    // Retrieve values
    try {
        bool verbose = parser.get<bool>("--verbose");
        int number = parser.get<int>("-n");
        std::string name = parser.get<std::string>("--name");
        auto key_value = parser.get<std::pair<std::string, std::string>>("--keyvalue");

        std::cout << "Verbose: " << std::boolalpha << verbose << "\n";
        std::cout << "Number: " << number << "\n";
        std::cout << "Name: " << name << "\n";
        std::cout << "Key: " << key_value.first << ", Value: " << key_value.second << "\n";
    }
    catch (const std::exception& ex) {
        std::cerr << "Retrieval error: " << ex.what() << "\n";
        return 1;
    }

    // Access positional arguments
    const auto& positional_args = parser.positional_arguments();
    if (!positional_args.empty()) {
        std::cout << "Positional Arguments:\n";
        for (const auto& arg : positional_args) {
            std::cout << "  " << arg << "\n";
        }
    }

    return 0;
}



================================================================================
// File: Parser.cpp
================================================================================

// Parser.cppm
module CPPLine;

import std;

namespace cppline {

Parser::Parser(const std::string& description)
    : description_(description) {}

void Parser::add_option(const std::vector<std::string>& names,
                        const std::string& help,
                        std::function<std::any(const std::vector<std::string_view>&)> parse_function,
                        size_t argument_count) {
    Option option{ names, help, argument_count, parse_function, std::any{}, false };
    options_.push_back(option);

    size_t index = options_.size() - 1;
    for (const auto& name : names) {
        option_map_[name] = index;
    }
}

void Parser::add_bool(const std::vector<std::string>& names, const std::string& help) {
    add_option(names, help,
               [](const std::vector<std::string_view>&) -> std::any {
                   return true; // Presence implies true
               },
               0); // No arguments after the option name
    // Set default value for all names
    for (const auto& name : names) {
        values_[name] = false; // Default is false
    }
}

void Parser::add_int(const std::vector<std::string>& names, const std::string& help, int default_value) {
    add_option(names, help,
               [](const std::vector<std::string_view>& args) -> std::any {
                   if (args.empty()) {
                       throw std::runtime_error("Expected a value");
                   }
                   return std::stoi(std::string(args[0]));
               },
               1); // One argument after the name
    // Set default value for all names
    for (const auto& name : names) {
        values_[name] = default_value;
    }
}

void Parser::add_string(const std::vector<std::string>& names, const std::string& help, const std::string& default_value) {
    add_option(names, help,
               [](const std::vector<std::string_view>& args) -> std::any {
                   if (args.empty()) {
                       throw std::runtime_error("Expected a value");
                   }
                   return std::string(args[0]);
               },
               1); // One argument after the name
    // Set default value for all names
    for (const auto& name : names) {
        values_[name] = default_value;
    }
}

void Parser::parse(const std::vector<std::string_view>& arguments) {
    using namespace std::ranges;

    auto args = arguments | views::common;
    auto it = args.begin();
    auto end = args.end();

    while (it != end) {
        std::string_view arg = *it;

        // Check if the argument matches any option name
        auto opt_map_it = option_map_.find(std::string(arg));
        if (opt_map_it != option_map_.end()) {
            // Option found
            Option& option = options_[opt_map_it->second];

            size_t args_to_consume = option.argument_count;
            if (std::distance(it, end) - 1 < static_cast<std::ptrdiff_t>(args_to_consume)) {
                throw std::runtime_error("Not enough arguments for option " + option.names[0]);
            }

            // Collect arguments for the parse function
            std::vector<std::string_view> args_view;
            if (args_to_consume > 0) {
                auto args_start = std::next(it);
                auto args_end = std::next(it, args_to_consume + 1); // +1 to include the option name
                args_view.assign(args_start, args_end);
            }

            // Parse and store the value
            try {
                std::any value = option.parse_function(args_view);
                option.value = value;
                option.is_set = true;

                // Store the value for each alias
                for (const auto& name : option.names) {
                    values_[name] = value;
                }
            }
            catch (const std::exception& e) {
                throw std::runtime_error("Error parsing option " + option.names[0] + ": " + e.what());
            }

            // Advance the iterator
            it = std::next(it, args_to_consume + 1);
        }
        else {
            // Positional argument
            positional_args_.push_back(arg);
            ++it;
        }
    }
}

const std::vector<std::string_view>& Parser::positional_arguments() const {
    return positional_args_;
}

void Parser::print_help() const {
    std::cout << description_ << "\n\n";
    std::cout << "Options:\n";

    for (const auto& option : options_) {
        std::string names_str = std::accumulate(
            option.names.begin(), option.names.end(), std::string{},
            [](const std::string& a, const std::string& b) {
                return a.empty() ? b : a + ", " + b;
            }
        );
        std::cout << "  " << names_str << "\t" << option.help << "\n";
    }
}


}



================================================================================
// File: Parser.ixx
================================================================================

// Parser.ixx
export module CPPLine;

import std;

namespace cppline {

struct Option {
    std::vector<std::string> names; // Supports aliases
    std::string help;
    size_t argument_count; // Number of arguments after the option name
    std::function<std::any(const std::vector<std::string_view>&)> parse_function;
    std::any value;
    bool is_set = false; // Indicates if the option was set
};

export class Parser {
public:
    Parser(const std::string& description);

    // General method to add an option
    void add_option(const std::vector<std::string>& names,
                    const std::string& help,
                    std::function<std::any(const std::vector<std::string_view>&)> parse_function,
                    size_t argument_count);

    // Specific methods for common types
    void add_bool(const std::vector<std::string>& names, const std::string& help);
    void add_int(const std::vector<std::string>& names, const std::string& help, int default_value = 0);
    void add_string(const std::vector<std::string>& names, const std::string& help, const std::string& default_value = "");

    // Parse the command-line arguments
    void parse(const std::vector<std::string_view>& arguments);

    // Retrieve the parsed value
    template <typename T>
    T get(const std::string& name) const {
        auto it = values_.find(name);
        if (it != values_.end()) {
            return std::any_cast<T>(it->second);
        }
        throw std::runtime_error("Option not found: " + name);
    }

    // Access positional arguments
    const std::vector<std::string_view>& positional_arguments() const;

    // Print help message
    void print_help() const;

private:
    std::string description_;
    std::vector<Option> options_;
    std::unordered_map<std::string, size_t> option_map_; // Maps option names to indices in options_
    std::unordered_map<std::string, std::any> values_;
    std::vector<std::string_view> positional_args_;
};

}


